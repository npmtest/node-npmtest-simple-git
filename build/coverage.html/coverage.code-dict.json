{"/home/travis/build/npmtest/node-npmtest-simple-git/test.js":"/* istanbul instrument in package npmtest_simple_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-git/lib.npmtest_simple_git.js":"/* istanbul instrument in package npmtest_simple_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_simple_git = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_simple_git = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-git/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-simple-git && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_simple_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_simple_git\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_simple_git.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_simple_git.rollup.js'] =\n            local.assetsDict['/assets.npmtest_simple_git.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_simple_git.__dirname + '/lib.npmtest_simple_git.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/index.js":"\nvar Git = require('./git');\n\nvar ChildProcess = require('child_process');\nvar Buffer = require('buffer').Buffer;\nvar exists = require('./util/exists');\n\nmodule.exports = function (baseDir) {\n\n    if (baseDir && !exists(baseDir, exists.FOLDER)) {\n        throw new Error(\"Cannot use simple-git on a directory that does not exist.\");\n    }\n\n    return new Git(baseDir || process.cwd(), ChildProcess, Buffer);\n};\n\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/git.js":"(function () {\n\n   'use strict';\n\n   var exists = require('./util/exists');\n\n   /**\n    * Git handling for node. All public functions can be chained and all `then` handlers are optional.\n    *\n    * @param {string} baseDir base directory for all processes to run\n    *\n    * @param {Object} ChildProcess The ChildProcess module\n    * @param {Function} Buffer The Buffer implementation to use\n    *\n    * @constructor\n    */\n   function Git (baseDir, ChildProcess, Buffer) {\n      this._baseDir = baseDir;\n      this._runCache = [];\n\n      this.ChildProcess = ChildProcess;\n      this.Buffer = Buffer;\n   }\n\n   /**\n    * @type {string} The command to use to reference the git binary\n    */\n   Git.prototype._command = 'git';\n\n   /**\n    * @type {Function} An optional handler to use when a child process is created\n    */\n   Git.prototype._outputHandler = null;\n\n   /**\n    * @type {boolean} Property showing whether logging will be silenced - defaults to true in a production environment\n    */\n   Git.prototype._silentLogging = /prod/.test(process.env.NODE_ENV);\n\n   /**\n    * Sets the path to a custom git binary, should either be `git` when there is an installation of git available on\n    * the system path, or a fully qualified path to the executable.\n    *\n    * @param {string} command\n    * @returns {Git}\n    */\n   Git.prototype.customBinary = function (command) {\n      this._command = command;\n      return this;\n   };\n\n   /**\n    * Sets the working directory of the subsequent commands.\n    *\n    * @param {string} workingDirectory\n    * @param {Function} [then]\n    * @returns {Git}\n    */\n   Git.prototype.cwd = function (workingDirectory, then) {\n      var git = this;\n      var next = Git.trailingFunctionArgument(arguments);\n\n      return this.then(function () {\n         git._baseDir = workingDirectory;\n         if (!exists(workingDirectory, exists.FOLDER)) {\n            Git.exception(git, 'Git.cwd: cannot change to non-directory \"' + workingDirectory + '\"', next);\n         }\n         else {\n            next && next(null, workingDirectory);\n         }\n      });\n   };\n\n   /**\n    * Sets a handler function to be called whenever a new child process is created, the handler function will be called\n    * with the name of the command being run and the stdout & stderr streams used by the ChildProcess.\n    *\n    * @example\n    * require('simple-git')\n    *    .outputHandler(function (command, stdout, stderr) {\n    *       stdout.pipe(process.stdout);\n    *    })\n    *    .checkout('https://github.com/user/repo.git');\n    *\n    * @see http://nodejs.org/api/child_process.html#child_process_class_childprocess\n    * @see http://nodejs.org/api/stream.html#stream_class_stream_readable\n    * @param {Function} outputHandler\n    * @returns {Git}\n    */\n   Git.prototype.outputHandler = function (outputHandler) {\n      this._outputHandler = outputHandler;\n      return this;\n   };\n\n   /**\n    * Initialize a git repo\n    *\n    * @param {Boolean} [bare=false]\n    * @param {Function} [then]\n    */\n   Git.prototype.init = function (bare, then) {\n      var commands = ['init'];\n      var next = Git.trailingFunctionArgument(arguments);\n\n      if (bare === true) {\n         commands.push('--bare');\n      }\n\n      return this._run(commands, function (err) {\n         next && next(err);\n      });\n   };\n\n   /**\n    * Check the status of the local repo\n    *\n    * @param {Function} [then]\n    */\n   Git.prototype.status = function (then) {\n      return this._run(\n         ['status', '--porcelain', '-b', '-u'],\n         Git._responseHandler(then, 'StatusSummary')\n      );\n   };\n\n   /**\n    * List the stash(s) of the local repo\n    *\n    * @param {Object|Array} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.stashList = function (options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n      var opt = (handler === then ? options : null) || {};\n\n      var splitter = opt.splitter || ';';\n      var command = [\"stash\", \"list\", \"--pretty=format:%H %ai %s%d %aN %ae\".replace(/\\s+/g, splitter)];\n      if (Array.isArray(opt)) {\n         command = command.concat(opt);\n      }\n\n      return this._run(command,\n         Git._responseHandler(handler, 'ListLogSummary', splitter)\n      );\n   };\n\n   /**\n    * Stash the local repo\n    *\n    * @param {Object|Array} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.stash = function (options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n      var command = [\"stash\"];\n\n      if (Array.isArray(options)) {\n         command = command.concat(options);\n      }\n      else {\n         Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && data);\n      });\n   };\n\n   /**\n    * Clone a git repo\n    *\n    * @param {string} repoPath\n    * @param {string} localPath\n    * @param {String[]} [options] Optional array of options to pass through to the clone command\n    * @param {Function} [then]\n    */\n   Git.prototype.clone = function (repoPath, localPath, options, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = ['clone'];\n      if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n      command.push(repoPath, localPath);\n\n      return this._run(command, function (err, data) {\n         next && next(err, data);\n      });\n   };\n\n   /**\n    * Mirror a git repo\n    *\n    * @param {string} repoPath\n    * @param {string} localPath\n    * @param {Function} [then]\n    */\n   Git.prototype.mirror = function (repoPath, localPath, then) {\n      return this.clone(repoPath, localPath, ['--mirror'], then);\n   };\n\n   /**\n    * Internally uses pull and tags to get the list of tags then checks out the latest tag.\n    *\n    * @param {Function} [then]\n    */\n   Git.prototype.checkoutLatestTag = function (then) {\n      var git = this;\n      return this.pull().tags(function (err, tags) {\n         git.checkout(tags.latest, then);\n      });\n   };\n\n   /**\n    * Adds one or more files to source control\n    *\n    * @param {string|string[]} files\n    * @param {Function} [then]\n    */\n   Git.prototype.add = function (files, then) {\n      return this._run(['add'].concat(files), function (err, data) {\n         then && then(err);\n      });\n   };\n\n   /**\n    * Commits changes in the current working directory - when specific file paths are supplied, only changes on those\n    * files will be committed.\n    *\n    * @param {string|string[]} message\n    * @param {string|string[]} [files]\n    * @param {Object} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.commit = function (message, files, options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n\n      var command = ['commit'];\n\n      [].concat(message).forEach(function (message) {\n         command.push('-m', message);\n      });\n\n      [].push.apply(command, [].concat(typeof files === \"string\" || Array.isArray(files) ? files : []));\n\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      return this._run(\n         command,\n         Git._responseHandler(handler, 'CommitSummary')\n      );\n   };\n\n   /**\n    * Gets a function to be used for logging.\n    *\n    * @param {string} level\n    * @param {string} [message]\n    *\n    * @returns {Function}\n    * @private\n    */\n   Git.prototype._getLog = function (level, message) {\n      var log = this._silentLogging ? function () {\n         } : console[level].bind(console);\n      if (arguments.length > 1) {\n         log(message);\n      }\n      return log;\n   };\n\n   /**\n    * Pull the updated contents of the current repo\n    *\n    * @param {string} [remote] When supplied must also include the branch\n    * @param {string} [branch] When supplied must also include the remote\n    * @param {Object} [options] Optionally include set of options to merge into the command\n    * @param {Function} [then]\n    */\n   Git.prototype.pull = function (remote, branch, options, then) {\n      var command = [\"pull\"];\n      var handler = Git.trailingFunctionArgument(arguments);\n\n      if (typeof remote === 'string' && typeof branch === 'string') {\n         command.push(remote, branch);\n      }\n\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      return this._run(command, Git._responseHandler(handler, 'PullSummary'));\n   };\n\n   /**\n    * Fetch the updated contents of the current repo.\n    *\n    * @example\n    *   .fetch('upstream', 'master') // fetches from master on remote named upstream\n    *   .fetch(function () {}) // runs fetch against default remote and branch and calls function\n    *\n    * @param {string} [remote]\n    * @param {string} [branch]\n    * @param {Function} [then]\n    */\n   Git.prototype.fetch = function (remote, branch, then) {\n      var command = [\"fetch\"];\n      var next = Git.trailingFunctionArgument(arguments);\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      if (typeof remote === 'string' && typeof branch === 'string') {\n         command.push(remote, branch);\n      }\n\n      if (Array.isArray(remote)) {\n         command = command.concat(remote);\n      }\n\n      return this._run(\n         command,\n         Git._responseHandler(next, 'FetchSummary'),\n         {\n            concatStdErr: true\n         }\n      );\n   };\n\n   /**\n    * Disables/enables the use of the console for printing warnings and errors, by default messages are not shown in\n    * a production environment.\n    *\n    * @param {boolean} silence\n    * @returns {Git}\n    */\n   Git.prototype.silent = function (silence) {\n      this._silentLogging = !!silence;\n      return this;\n   };\n\n   /**\n    * List all tags. When using git 2.7.0 or above, include an options object with `\"--sort\": \"property-name\"` to\n    * sort the tags by that property instead of using the default semantic versioning sort.\n    *\n    * Note, supplying this option when it is not supported by your Git version will cause the operation to fail.\n    *\n    * @param {Object} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.tags = function (options, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n\n      var command = ['-l'];\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      var hasCustomSort = command.some(function (option) {\n         return /^--sort=/.test(option);\n      });\n\n      return this.tag(\n         command,\n         Git._responseHandler(next, 'TagList', [hasCustomSort])\n      );\n   };\n\n   /**\n    * Rebases the current working copy. Options can be supplied either as an array of string parameters\n    * to be sent to the `git rebase` command, or a standard options object.\n    *\n    * @param {Object|String[]} [options]\n    * @param {Function} [then]\n    * @returns {Git}\n    */\n   Git.prototype.rebase = function (options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n      var command = ['rebase'];\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && data);\n      })\n   };\n\n   /**\n    * Reset a repo\n    *\n    * @param {string|string[]} [mode=soft] Either an array of arguments supported by the 'git reset' command, or the\n    *                                        string value 'soft' or 'hard' to set the reset mode.\n    * @param {Function} [then]\n    */\n   Git.prototype.reset = function (mode, then) {\n      var command = ['reset'];\n      var next = Git.trailingFunctionArgument(arguments);\n      if (next === mode || typeof mode === 'string' || !mode) {\n         command.push('--' + (mode === 'hard' ? mode : 'soft'));\n      }\n      else if (Array.isArray(mode)) {\n         command.push.apply(command, mode);\n      }\n\n      return this._run(command, function (err) {\n         next && next(err || null);\n      });\n   };\n\n   /**\n    * Revert one or more commits in the local working copy\n    *\n    * @param {string} commit The commit to revert. Can be any hash, offset (eg: `HEAD~2`) or range (eg: `master~5..master~2`)\n    * @param {Object} [options] Optional options object\n    * @param {Function} [then]\n    */\n   Git.prototype.revert = function (commit, options, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = ['revert'];\n\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      if (typeof commit !== 'string') {\n         return this.then(function () {\n            next && next(new TypeError(\"Commit must be a string\"));\n         });\n      }\n\n      command.push(commit);\n      return this._run(command, function (err) {\n         next && next(err || null);\n      });\n   };\n\n   /**\n    * Add a lightweight tag to the head of the current branch\n    *\n    * @param {string} name\n    * @param {Function} [then]\n    */\n   Git.prototype.addTag = function (name, then) {\n      if (typeof name !== \"string\") {\n         return this.then(function () {\n            then && then(new TypeError(\"Git.addTag requires a tag name\"));\n         });\n      }\n\n      return this.tag([name], then);\n   };\n\n   /**\n    * Add an annotated tag to the head of the current branch\n    *\n    * @param {string} tagName\n    * @param {string} tagMessage\n    * @param {Function} [then]\n    */\n   Git.prototype.addAnnotatedTag = function (tagName, tagMessage, then) {\n      return this.tag(['-a', '-m', tagMessage, tagName], function (err) {\n         then && then(err);\n      });\n   };\n\n   /**\n    * Check out a tag or revision, any number of additional arguments can be passed to the `git checkout` command\n    * by supplying either a string or array of strings as the `what` parameter.\n    *\n    * @param {string|string[]} what One or more commands to pass to `git checkout`\n    * @param {Function} [then]\n    */\n   Git.prototype.checkout = function (what, then) {\n      var command = ['checkout'];\n      command = command.concat(what);\n\n      return this._run(command, function (err, data) {\n         then && then(err, !err && this._parseCheckout(data));\n      });\n   };\n\n   /**\n    * Check out a remote branch\n    *\n    * @param {string} branchName name of branch\n    * @param {string} startPoint (e.g origin/development)\n    * @param {Function} [then]\n    */\n   Git.prototype.checkoutBranch = function (branchName, startPoint, then) {\n      return this.checkout(['-b', branchName, startPoint], then);\n   };\n\n   /**\n    * Check out a local branch\n    *\n    * @param {string} branchName of branch\n    * @param {Function} [then]\n    */\n   Git.prototype.checkoutLocalBranch = function (branchName, then) {\n      return this.checkout(['-b', branchName], then);\n   };\n\n   /**\n    * Delete a local branch\n    *\n    * @param {string} branchName name of branch\n    * @param {Function} [then]\n    */\n   Git.prototype.deleteLocalBranch = function (branchName, then) {\n      return this.branch(['-d', branchName], then);\n   };\n\n   /**\n    * List all branches\n    *\n    * @param {Object} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.branch = function (options, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = ['branch'];\n      if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n      if (!arguments.length || next === options) {\n         command.push('-a', '-v');\n      }\n\n      return this._run(command, command.indexOf('-d') > 0\n         ? Git._responseHandler(next, 'BranchDeleteSummary', false)\n         : Git._responseHandler(next, 'BranchSummary'));\n   };\n\n   /**\n    * Return list of local branches\n    *\n    * @param {Function} [then]\n    */\n   Git.prototype.branchLocal = function (then) {\n      return this.branch(['-v'], then);\n   };\n\n   /**\n    * Add config to local git instance\n    *\n    * @param {string} key configuration key (e.g user.name)\n    * @param {string} value for the given key (e.g your name)\n    * @param {Function} [then]\n    */\n   Git.prototype.addConfig = function (key, value, then) {\n      return this._run(['config', '--local', key, value], function (err, data) {\n         then && then(err, !err && data);\n      });\n   };\n\n   /**\n    * Executes any command against the git binary.\n    *\n    * @param {string[]|Object} commands\n    * @param {Function} [then]\n    *\n    * @returns {Git}\n    */\n   Git.prototype.raw = function (commands, then) {\n      var command = [];\n      if (Array.isArray(commands)) {\n         command = commands.slice(0);\n      }\n      else {\n         Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n      }\n\n      var next = Git.trailingFunctionArgument(arguments);\n\n      if (!command.length) {\n         return this.then(function () {\n            next && next(new Error('Raw: must supply one or more command to execute'), null);\n         });\n      }\n\n      return this._run(command, function (err, data) {\n         next && next(err, !err && data || null);\n      });\n   };\n\n   /**\n    * Add a submodule\n    *\n    * @param {string} repo\n    * @param {string} path\n    * @param {Function} [then]\n    */\n   Git.prototype.submoduleAdd = function (repo, path, then) {\n      return this._run(['submodule', 'add', repo, path], function (err) {\n         then && then(err);\n      });\n   };\n\n   /**\n    * Update submodules\n    *\n    * @param {string[]} [args]\n    * @param {Function} [then]\n    */\n   Git.prototype.submoduleUpdate = function (args, then) {\n      if (typeof args === 'string') {\n         this._getLog('warn', 'Git#submoduleUpdate: args should be supplied as an array of individual arguments');\n      }\n\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = (args !== next) ? args : [];\n\n      return this.subModule(['update'].concat(command), function (err, args) {\n         next && next(err, args);\n      });\n   };\n\n   /**\n    * Initialize submodules\n    *\n    * @param {string[]} [args]\n    * @param {Function} [then]\n    */\n   Git.prototype.submoduleInit = function (args, then) {\n      if (typeof args === 'string') {\n         this._getLog('warn', 'Git#submoduleInit: args should be supplied as an array of individual arguments');\n      }\n\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = (args !== next) ? args : [];\n\n      return this.subModule(['init'].concat(command), function (err, args) {\n         next && next(err, args);\n      });\n   };\n\n   /**\n    * Call any `git submodule` function with arguments passed as an array of strings.\n    *\n    * @param {string[]} options\n    * @param {Function} [then]\n    */\n   Git.prototype.subModule = function (options, then) {\n      if (!Array.isArray(options)) {\n         return this.then(function () {\n            then && then(new TypeError(\"Git.subModule requires an array of arguments\"));\n         });\n      }\n\n      if (options[0] !== 'submodule') {\n         options.unshift('submodule');\n      }\n\n      return this._run(options, function (err, data) {\n         then && then(err || null, err ? null : data);\n      });\n   };\n\n   /**\n    * List remote\n    *\n    * @param {string[]} [args]\n    * @param {Function} [then]\n    */\n   Git.prototype.listRemote = function (args, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var data = next === args || args === undefined ? [] : args;\n\n      if (typeof data === 'string') {\n         this._getLog('warn', 'Git#listRemote: args should be supplied as an array of individual arguments');\n      }\n\n      return this._run(['ls-remote'].concat(data), function (err, data) {\n         next && next(err, data);\n      });\n   };\n\n   /**\n    * Adds a remote to the list of remotes.\n    *\n    * @param {string} remoteName Name of the repository - eg \"upstream\"\n    * @param {string} remoteRepo Fully qualified SSH or HTTP(S) path to the remote repo\n    * @param {Function} [then]\n    * @returns {*}\n    */\n   Git.prototype.addRemote = function (remoteName, remoteRepo, then) {\n      return this._run(['remote', 'add', remoteName, remoteRepo], function (err) {\n         then && then(err);\n      });\n   };\n\n   /**\n    * Removes an entry from the list of remotes.\n    *\n    * @param {string} remoteName Name of the repository - eg \"upstream\"\n    * @param {Function} [then]\n    * @returns {*}\n    */\n   Git.prototype.removeRemote = function (remoteName, then) {\n      return this._run(['remote', 'remove', remoteName], function (err) {\n         then && then(err);\n      });\n   };\n\n   /**\n    * Gets the currently available remotes, setting the optional verbose argument to true includes additional\n    * detail on the remotes themselves.\n    *\n    * @param {boolean} [verbose=false]\n    * @param {Function} [then]\n    */\n   Git.prototype.getRemotes = function (verbose, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var args = verbose === true ? ['-v'] : [];\n\n      return this.remote(args, function (err, data) {\n         next && next(err, !err && function () {\n               return data.trim().split('\\n').reduce(function (remotes, remote) {\n                  var detail = remote.trim().split(/\\s+/);\n                  var name = detail.shift();\n\n                  if (!remotes[name]) {\n                     remotes[name] = remotes[remotes.length] = {\n                        name: name,\n                        refs: {}\n                     };\n                  }\n\n                  if (detail.length) {\n                     remotes[name].refs[detail.pop().replace(/[^a-z]/g, '')] = detail.pop();\n                  }\n\n                  return remotes;\n               }, []).slice(0);\n            }());\n      });\n   };\n\n   /**\n    * Call any `git remote` function with arguments passed as an array of strings.\n    *\n    * @param {string[]} options\n    * @param {Function} [then]\n    */\n   Git.prototype.remote = function (options, then) {\n      if (!Array.isArray(options)) {\n         return this.then(function () {\n            then && then(new TypeError(\"Git.remote requires an array of arguments\"));\n         });\n      }\n\n      if (options[0] !== 'remote') {\n         options.unshift('remote');\n      }\n\n      return this._run(options, function (err, data) {\n         then && then(err || null, err ? null : data);\n      });\n   };\n\n   /**\n    * Merges from one branch to another, equivalent to running `git merge ${from} $[to}`, the `options` argument can\n    * either be an array of additional parameters to pass to the command or null / omitted to be ignored.\n    *\n    * @param {string} from\n    * @param {string} to\n    * @param {Object} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.mergeFromTo = function (from, to, options, then) {\n      var commands = [\n         from,\n         to\n      ];\n      var callback = Git.trailingFunctionArgument(arguments);\n\n      if (Array.isArray(options)) {\n         commands = commands.concat(options);\n      }\n\n      return this.merge(commands, callback);\n   };\n\n   Git.prototype.merge = function (options, then) {\n      if (!Array.isArray(options)) {\n         return this.then(function () {\n            then && then(new TypeError(\"Git.merge requires an array of arguments\"));\n         });\n      }\n\n      if (options[0] !== 'merge') {\n         options.unshift('merge');\n      }\n\n      return this._run(options, function (err, data) {\n         then && then(err || null, err ? null : data);\n      });\n   };\n\n   /**\n    * Call any `git tag` function with arguments passed as an array of strings.\n    *\n    * @param {string[]} options\n    * @param {Function} [then]\n    */\n   Git.prototype.tag = function (options, then) {\n      if (!Array.isArray(options)) {\n         return this.then(function () {\n            then && then(new TypeError(\"Git.tag requires an array of arguments\"));\n         });\n      }\n\n      if (options[0] !== 'tag') {\n         options.unshift('tag');\n      }\n\n      return this._run(options, function (err, data) {\n         then && then(err || null, err ? null : data);\n      });\n   };\n\n   /**\n    * Updates repository server info\n    *\n    * @param {Function} [then]\n    */\n   Git.prototype.updateServerInfo = function (then) {\n      return this._run([\"update-server-info\"], function (err, data) {\n         then && then(err, !err && data);\n      });\n   };\n\n   /**\n    * Pushes the current committed changes to a remote, optionally specify the names of the remote and branch to use\n    * when pushing. Supply multiple options as an array of strings in the first argument - see examples below.\n    *\n    * @param {string|string[]} [remote]\n    * @param {string} [branch]\n    * @param {Function} [then]\n    */\n   Git.prototype.push = function (remote, branch, then) {\n      var command = [];\n      var handler = Git.trailingFunctionArgument(arguments);\n\n      if (typeof remote === 'string' && typeof branch === 'string') {\n         command.push(remote, branch);\n      }\n\n      if (Array.isArray(remote)) {\n         command = command.concat(remote);\n      }\n\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      if (command[0] !== 'push') {\n         command.unshift('push');\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && data);\n      });\n   };\n\n   /**\n    * Pushes the current tag changes to a remote which can be either a URL or named remote. When not specified uses the\n    * default configured remote spec.\n    *\n    * @param {string} [remote]\n    * @param {Function} [then]\n    */\n   Git.prototype.pushTags = function (remote, then) {\n      var command = ['push'];\n      if (typeof remote === \"string\") {\n         command.push(remote);\n      }\n      command.push('--tags');\n\n      then = typeof arguments[arguments.length - 1] === \"function\" ? arguments[arguments.length - 1] : null;\n\n      return this._run(command, function (err, data) {\n         then && then(err, !err && data);\n      });\n   };\n\n   /**\n    * Removes the named files from source control.\n    *\n    * @param {string|string[]} files\n    * @param {Function} [then]\n    */\n   Git.prototype.rm = function (files, then) {\n      return this._rm(files, '-f', then);\n   };\n\n   /**\n    * Removes the named files from source control but keeps them on disk rather than deleting them entirely. To\n    * completely remove the files, use `rm`.\n    *\n    * @param {string|string[]} files\n    * @param {Function} [then]\n    */\n   Git.prototype.rmKeepLocal = function (files, then) {\n      return this._rm(files, '--cached', then);\n   };\n\n   /**\n    * Returns a list of objects in a tree based on commit hash. Passing in an object hash returns the object's content,\n    * size, and type.\n    *\n    * Passing \"-p\" will instruct cat-file to determine the object type, and display its formatted contents.\n    *\n    * @param {string[]} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.catFile = function (options, then) {\n      return this._catFile('utf-8', arguments);\n   };\n\n   /**\n    * Equivalent to `catFile` but will return the native `Buffer` of content from the git command's stdout.\n    *\n    * @param {string[]} options\n    * @param then\n    */\n   Git.prototype.binaryCatFile = function (options, then) {\n      return this._catFile('buffer', arguments);\n   };\n\n   Git.prototype._catFile = function (format, args) {\n      var handler = Git.trailingFunctionArgument(args);\n      var command = ['cat-file'];\n      var options = args[0];\n\n      if (typeof options === 'string') {\n         throw new TypeError('Git#catFile: options must be supplied as an array of strings');\n      }\n      else if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, data);\n      }, {\n         format: format\n      });\n   };\n\n   /**\n    * Return repository changes.\n    *\n    * @param {string} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.diff = function (options, then) {\n      var command = ['diff'];\n\n      if (typeof options === 'string') {\n         command[0] += ' ' + options;\n         this._getLog('warn',\n            'Git#diff: supplying options as a single string is now deprecated, switch to an array of strings');\n      }\n      else if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      if (typeof arguments[arguments.length - 1] === 'function') {\n         then = arguments[arguments.length - 1];\n      }\n\n      return this._run(command, function (err, data) {\n         then && then(err, data);\n      });\n   };\n\n   Git.prototype.diffSummary = function (options, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = ['--stat'];\n\n      if (options && options !== next) {\n         command.push.apply(command, [].concat(options));\n      }\n\n      return this.diff(command, Git._responseHandler(next, 'DiffSummary'));\n   };\n\n   /**\n    * rev-parse.\n    *\n    * @param {string|string[]} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.revparse = function (options, then) {\n      var command = ['rev-parse'];\n\n      if (typeof options === 'string') {\n         command = command + ' ' + options;\n         this._getLog('warn',\n            'Git#revparse: supplying options as a single string is now deprecated, switch to an array of strings');\n      }\n      else if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      if (typeof arguments[arguments.length - 1] === 'function') {\n         then = arguments[arguments.length - 1];\n      }\n\n      return this._run(command, function (err, data) {\n         then && then(err, data);\n      });\n   };\n\n   /**\n    * Show various types of objects, for example the file at a certain commit\n    *\n    * @param {string} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.show = function (options, then) {\n      var args = [].slice.call(arguments, 0);\n      var handler = typeof args[args.length - 1] === \"function\" ? args.pop() : null;\n      var command = ['show'];\n      if (typeof options === 'string') {\n         command = command + ' ' + options;\n         this._getLog('warn',\n            'Git#show: supplying options as a single string is now deprecated, switch to an array of strings');\n      }\n      else if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && data);\n      });\n   };\n\n   /**\n    * @param {string} mode Required parameter \"n\" or \"f\"\n    * @param {Array} options\n    * @param {Function} [then]\n    */\n   Git.prototype.clean = function (mode, options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n\n      if (!/^[nf]$/.test(mode)) {\n         return this.then(function () {\n            handler && handler(new TypeError('Git clean mode parameter (\"n\" or \"f\") is required'));\n         });\n      }\n\n      var command = ['clean', '-' + mode];\n      if (Array.isArray(options)) {\n         command = command.concat(options);\n      }\n\n      if (command.indexOf('-i') > 0) {\n         return this.then(function () {\n            handler && handler(new TypeError('Git clean interactive mode is not supported'));\n         });\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && data);\n      });\n   };\n\n   /**\n    * Call a simple function\n    * @param {Function} [then]\n    */\n   Git.prototype.then = function (then) {\n      this._run([], function () {\n         typeof then === 'function' && then();\n      });\n      return this;\n   };\n\n   /**\n    * Show commit logs.\n    *\n    * @param {Object|string[]} [options]\n    * @param {string} [options.from] The first commit to include\n    * @param {string} [options.to] The most recent commit to include\n    * @param {string} [options.file] A single file to include in the result\n    *\n    * @param {Function} [then]\n    */\n   Git.prototype.log = function (options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n      var opt = (handler === then ? options : null) || {};\n\n      var splitter = opt.splitter || ';';\n      var format = opt.format || {\n            hash: '%H',\n            date: '%ai',\n            message: '%s%d',\n            author_name: '%aN',\n            author_email: '%ae'\n         };\n\n      var fields = Object.keys(format);\n      var formatstr = fields.map(function (k) {\n         return format[k];\n      }).join(splitter);\n      var command = [\"log\", \"--pretty=format:\" + formatstr + require('./responses/ListLogSummary').COMMIT_BOUNDARY];\n\n      if (Array.isArray(opt)) {\n         command = command.concat(opt);\n         opt = {};\n      }\n      else if (typeof arguments[0] === \"string\" || typeof arguments[1] === \"string\") {\n         this._getLog('warn',\n            'Git#log: supplying to or from as strings is now deprecated, switch to an options configuration object');\n         opt = {\n            from: arguments[0],\n            to: arguments[1]\n         };\n      }\n\n      if (opt.from && opt.to) {\n         command.push(opt.from + \"...\" + opt.to);\n      }\n\n      if (opt.file) {\n         command.push(\"--follow\", options.file);\n      }\n\n      if (opt.n || opt['max-count']) {\n         command.push(\"--max-count=\" + (opt.n || opt['max-count']));\n      }\n\n      'splitter n max-count file from to --pretty format'.split(' ').forEach(function (key) {\n         delete opt[key];\n      });\n\n      Git._appendOptions(command, opt);\n\n      return this._run(command, Git._responseHandler(handler, 'ListLogSummary', [splitter, fields]));\n   };\n\n   /**\n    * Check if a pathname or pathnames are excluded by .gitignore\n    *\n    * @param {string|string[]} pathnames\n    * @param {Function} [then]\n    */\n   Git.prototype.checkIgnore = function (pathnames, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n      var command = [\"check-ignore\"];\n\n      if (handler !== pathnames) {\n         command = command.concat(pathnames);\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && this._parseCheckIgnore(data));\n      });\n   };\n\n   Git.prototype._rm = function (_files, options, then) {\n      var files = [].concat(_files);\n      var args = ['rm', options];\n      args.push.apply(args, files);\n\n      return this._run(args, function (err) {\n         then && then(err);\n      });\n   };\n\n   Git.prototype._parseCheckout = function (checkout) {\n      // TODO\n   };\n\n   /**\n    * Parser for the `check-ignore` command - returns each\n    * @param {string} [files]\n    * @returns {string[]}\n    */\n   Git.prototype._parseCheckIgnore = function (files) {\n      return files.split(/\\n/g).filter(Boolean).map(function (file) {\n         return file.trim()\n      });\n   };\n\n   /**\n    * Schedules the supplied command to be run, the command should not include the name of the git binary and should\n    * be an array of strings passed as the arguments to the git binary.\n    *\n    * @param {string[]} command\n    * @param {Function} then\n    * @param {Object} [opt]\n    * @param {boolean} [opt.concatStdErr=false] Optionally concatenate stderr output into the stdout\n    * @param {boolean} [opt.format=\"utf-8\"] The format to use when reading the content of stdout\n    *\n    * @returns {Git}\n    */\n   Git.prototype._run = function (command, then, opt) {\n      if (typeof command === \"string\") {\n         command = command.split(\" \");\n      }\n      this._runCache.push([command, then, opt || {}]);\n      this._schedule();\n\n      return this;\n   };\n\n   Git.prototype._schedule = function () {\n      if (!this._childProcess && this._runCache.length) {\n         var Buffer = this.Buffer;\n         var task = this._runCache.shift();\n         var command = task[0];\n         var then = task[1];\n         var options = task[2];\n\n         var stdOut = [];\n         var stdErr = [];\n         var spawned = this.ChildProcess.spawn(this._command, command.slice(0), {\n            cwd: this._baseDir\n         });\n\n         spawned.stdout.on('data', function (buffer) {\n            stdOut.push(buffer);\n         });\n         spawned.stderr.on('data', function (buffer) {\n            stdErr.push(buffer);\n         });\n\n         spawned.on('error', function (err) {\n            stdErr.push(new Buffer(err.stack, 'ascii'));\n         });\n\n         spawned.on('close', function (exitCode, exitSignal) {\n            delete this._childProcess;\n\n            if (exitCode && stdErr.length) {\n               stdErr = Buffer.concat(stdErr).toString('utf-8');\n\n               this._getLog('error', stdErr);\n               this._runCache = [];\n               then.call(this, stdErr, null);\n            }\n            else {\n               if (options.concatStdErr) {\n                  [].push.apply(stdOut, stdErr);\n               }\n\n               var stdOutput = Buffer.concat(stdOut);\n               if (options.format !== 'buffer') {\n                  stdOutput = stdOutput.toString(options.format || 'utf-8');\n               }\n\n               then.call(this, null, stdOutput);\n            }\n\n            process.nextTick(this._schedule.bind(this));\n         }.bind(this));\n\n         this._childProcess = spawned;\n\n         if (this._outputHandler) {\n            this._outputHandler(command[0],\n               this._childProcess.stdout,\n               this._childProcess.stderr);\n         }\n      }\n   };\n\n   /**\n    * Given any number of arguments, returns the last argument if it is a function, otherwise returns null.\n    * @returns {Function|null}\n    */\n   Git.trailingFunctionArgument = function (args) {\n      var trailing = args[args.length - 1];\n      return (typeof trailing === \"function\") ? trailing : null;\n   };\n\n   /**\n    * Given any number of arguments, returns the trailing options argument, ignoring a trailing function argument\n    * if there is one. When not found, the return value is null.\n    * @returns {Object|null}\n    */\n   Git.trailingOptionsArgument = function (args) {\n      var options = args[(args.length - (Git.trailingFunctionArgument(args) ? 2 : 1))];\n      return Object.prototype.toString.call(options) === '[object Object]' ? options : null;\n   };\n\n   /**\n    * Mutates the supplied command array by merging in properties in the options object. When the\n    * value of the item in the options object is a string it will be concatenated to the key as\n    * a single `name=value` item, otherwise just the name will be used.\n    *\n    * @param {string[]} command\n    * @param {Object} options\n    * @private\n    */\n   Git._appendOptions = function (command, options) {\n      if (options === null) {\n         return;\n      }\n\n      Object.keys(options).forEach(function (key) {\n         var value = options[key];\n         if (typeof value === 'string') {\n            command.push(key + '=' + value);\n         }\n         else {\n            command.push(key);\n         }\n      });\n   };\n\n   /**\n    * Given the type of response and the callback to receive the parsed response,\n    * uses the correct parser and calls back the callback.\n    *\n    * @param {Function} callback\n    * @param {string} type\n    * @param {Object[]} [args]\n    *\n    * @private\n    */\n   Git._responseHandler = function (callback, type, args) {\n      return function (error, data) {\n         if (typeof callback !== 'function') {\n            return;\n         }\n\n         if (error) {\n            callback(error, null);\n            return;\n         }\n\n         var handler = require('./responses/' + type);\n         var result = handler.parse.apply(handler, [data].concat(args === undefined ? [] : args));\n\n         callback(null, result);\n      };\n\n   };\n\n   /**\n    * Marks the git instance as having had a fatal exception by clearing the pending queue of tasks and\n    * logging to the console.\n    *\n    * @param git\n    * @param error\n    * @param callback\n    */\n   Git.exception = function (git, error, callback) {\n      git._runCache.length = 0;\n      if (typeof callback === 'function') {\n         callback(error instanceof Error ? error : new Error(error));\n      }\n\n      git._getLog('error', error);\n   };\n\n   module.exports = Git;\n\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/util/exists.js":"\nvar fs = require('fs');\n\nfunction exists (path, isFile, isDirectory) {\n   try {\n      var matches = false;\n      var stat = fs.statSync(path);\n\n      matches = matches || isFile && stat.isFile();\n      matches = matches || isDirectory && stat.isDirectory();\n\n      return matches;\n   }\n   catch (e) {\n      if (e.code === 'ENOENT') {\n         return false;\n      }\n\n      throw e;\n   }\n}\n\nmodule.exports = function (path, type) {\n   if (!type) {\n      return exists(path, true, true);\n   }\n\n   return exists(path, type & 1, type & 2);\n};\n\nmodule.exports.FILE = 1;\n\nmodule.exports.FOLDER = 2;\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/GruntFile.js":"module.exports = function (grunt) {\n\n   'use strict';\n\n   grunt.initConfig({\n      pkg: grunt.file.readJSON('package.json'),\n\n      nodeunit: {\n         unit: ['test/unit/test*.js'],\n         integration: ['test/integration/test*.js']\n      },\n\n      release: {\n         options: {\n            file: 'package.json',\n            tagName: '<%= version %>', //default: '<%= version %>'\n            commitMessage: 'Release <%= version %>', //default: 'release <%= version %>'\n            tagMessage: 'Tag version <%= version %>' //default: 'Version <%= version %>'\n         }\n      },\n\n      clean: {\n         typings: {\n            src: [\n               '*.d.ts',\n               '*/**.d.ts',\n               '!typings/**/*.d.ts',\n               '!node_modules/**.*'\n            ]\n         }\n      },\n\n      copy: {\n         typings: {\n            files: [\n               {expand: true, cwd: './typings', src: ['./**'], dest: '.'}\n            ]\n         }\n      }\n   });\n\n   grunt.loadNpmTasks('grunt-contrib-nodeunit');\n   grunt.loadNpmTasks('grunt-release-steps');\n   grunt.loadNpmTasks('grunt-contrib-clean');\n   grunt.loadNpmTasks('grunt-contrib-copy');\n\n   grunt.registerTask('-to-npm', ['copy:typings', 'release:npm', 'clean:typings']);\n   grunt.registerTask('-to-git', ['release:add:commit:push']);\n   grunt.registerTask('-tag', ['release:tag:pushTags']);\n\n   'patch minor major'.split(' ').forEach(function (type) {\n      grunt.registerTask(type, [\n         'clean',\n         'test',\n         'release:bump:' + type, '-tag',\n         '-to-git',\n         '-to-npm'\n      ]);\n   });\n\n   grunt.registerTask('default', ['patch']);\n   grunt.registerTask('test', ['nodeunit:unit', 'nodeunit:integration']);\n\n};\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/promise.js":"'use strict';\n\nif (typeof Promise === 'undefined') {\n   throw new ReferenceError(\"Promise wrappers must be enabled to use the promise API\");\n}\n\nfunction asyncWrapper (fn, git, chain) {\n   return function () {\n      var args = [].slice.call(arguments);\n\n      if (typeof args[args.length] === 'function') {\n         throw new TypeError(\n            \"Promise interface requires that handlers are not supplied inline, \" +\n            \"trailing function not allowed in call to \" + fn);\n      }\n\n      return chain.then(function () {\n         return new Promise(function (resolve, reject) {\n            args.push(function (err, result) {\n               if (err) {\n                  reject(new Error(err));\n               }\n               else {\n                  resolve(result);\n               }\n            });\n\n            git[fn].apply(git, args);\n         });\n      });\n   };\n}\n\nfunction syncWrapper (fn, git, api) {\n   return function () {\n      git[fn].apply(git, arguments);\n\n      return api;\n   };\n}\n\nfunction isAsyncCall (fn) {\n   return /^[^\\)]+then\\s*\\)/.test(fn) || /\\._run\\(/.test(fn);\n}\n\nmodule.exports = function (baseDir) {\n\n   var git;\n   var chain = Promise.resolve();\n\n   try {\n      git = require('./src')(baseDir);\n   }\n   catch (e) {\n      chain = Promise.reject(e);\n   }\n\n   return Object.keys(git.constructor.prototype).reduce(function (api, fn) {\n      if (/^_|then/.test(fn)) {\n         return api;\n      }\n\n      if (isAsyncCall(git[fn])) {\n         api[fn] = asyncWrapper(fn, git, chain);\n      }\n\n      else {\n         api[fn] = syncWrapper(fn, git, api);\n      }\n\n      return api;\n\n   }, {});\n\n};\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/responses/BranchDeleteSummary.js":"\nmodule.exports = BranchDeletion;\n\nfunction BranchDeletion (branch, hash) {\n   this.branch = branch;\n   this.hash = hash;\n   this.success = hash !== null;\n}\n\nBranchDeletion.deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^\\)]+)\\)/;\nBranchDeletion.deleteErrorRegex = /^error[^']+'([^']+)'/;\n\nBranchDeletion.parse = function (data, asArray) {\n   var result;\n   var branchDeletions = data.trim().split('\\n').map(function (line) {\n         if (result = BranchDeletion.deleteSuccessRegex.exec(line)) {\n            return new BranchDeletion(result[1], result[2]);\n         }\n         else if (result = BranchDeletion.deleteErrorRegex.exec(line)) {\n            return new BranchDeletion(result[1], null);\n         }\n      })\n      .filter(Boolean);\n\n   return asArray ? branchDeletions : branchDeletions.pop();\n};\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/responses/BranchSummary.js":"\nmodule.exports = BranchSummary;\n\nfunction BranchSummary () {\n   this.detached = false;\n   this.current = '';\n   this.all = [];\n   this.branches = {};\n}\n\nBranchSummary.prototype.push = function (current, detached, name, commit, label) {\n   if (current) {\n      this.detached = detached;\n      this.current = name;\n   }\n   this.all.push(name);\n   this.branches[name] = {\n      current: current,\n      name: name,\n      commit: commit,\n      label: label\n   };\n};\n\nBranchSummary.detachedRegex = /^(\\*?\\s+)\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/;\nBranchSummary.branchRegex = /^(\\*?\\s+)(\\S+)\\s+([a-z0-9]+)\\s(.*)$/;\n\nBranchSummary.parse = function (commit) {\n   var branchSummary = new BranchSummary();\n\n   commit.split('\\n')\n      .forEach(function (line) {\n         var detached = true;\n         var branch = BranchSummary.detachedRegex.exec(line);\n         if (!branch) {\n            detached = false;\n            branch = BranchSummary.branchRegex.exec(line);\n         }\n\n         if (branch) {\n            branchSummary.push(\n               branch[1].charAt(0) === '*',\n               detached,\n               branch[2],\n               branch[3],\n               branch[4]\n            );\n         }\n      });\n\n   return branchSummary;\n};\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/responses/CommitSummary.js":"\nmodule.exports = CommitSummary;\n\nfunction CommitSummary () {\n   this.branch = '';\n   this.commit = '';\n   this.summary = {\n      changes: 0,\n      insertions: 0,\n      deletions: 0\n   };\n}\n\nCommitSummary.prototype.setBranchFromCommit = function (commitData) {\n   if (commitData) {\n      this.branch = commitData[1];\n      this.commit = commitData[2];\n   }\n};\n\nCommitSummary.prototype.setSummaryFromCommit = function (commitData) {\n   if (this.branch && commitData) {\n      this.summary.changes = commitData[1] || 0;\n      this.summary.insertions = commitData[2] || 0;\n      this.summary.deletions = commitData[3] || 0;\n   }\n};\n\nCommitSummary.parse = function (commit) {\n   var lines = commit.trim().split('\\n');\n\n   var commitSummary = new CommitSummary();\n   commitSummary.setBranchFromCommit(/\\[([^\\s]+) ([^\\]]+)/.exec(lines.shift()));\n   commitSummary.setSummaryFromCommit(/(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)?(?:,\\s*(\\d+))?/g.exec(lines.shift()));\n\n   return commitSummary;\n};\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/responses/DiffSummary.js":"\nmodule.exports = DiffSummary;\n\n/**\n * The DiffSummary is returned as a response to getting `git().status()`\n *\n * @constructor\n */\nfunction DiffSummary () {\n   this.files = [];\n   this.insertions = 0;\n   this.deletions = 0;\n}\n\n/**\n * Number of lines added\n * @type {number}\n */\nDiffSummary.prototype.insertions = 0;\n\n/**\n * Number of lines deleted\n * @type {number}\n */\nDiffSummary.prototype.deletions = 0;\n\nDiffSummary.parse = function (text) {\n   var line, handler;\n\n   var lines = text.trim().split('\\n');\n   var status = new DiffSummary();\n\n   var summary = lines.pop();\n   if (summary) {\n      summary.trim().split(', ').slice(1).forEach(function (text) {\n         var summary = /(\\d+)\\s([a-z]+)/.exec(text);\n         if (summary) {\n            status[summary[2].replace(/s$/, '') + 's'] = parseInt(summary[1], 10);\n         }\n      });\n   }\n\n   while (line = lines.shift()) {\n      line = line.trim().match(/^(.+)\\s+\\|\\s+(\\d+)\\s+([+\\-]+)$/);\n      if (line) {\n         status.files.push({\n            file: line[1].trim(),\n            changes: parseInt(line[2], 10),\n            insertions: line[3].replace(/\\-/g, '').length,\n            deletions: line[3].replace(/\\+/g, '').length\n         });\n      }\n   }\n\n   return status;\n};\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/responses/FetchSummary.js":"'use strict';\n\nfunction FetchSummary (raw) {\n   this.raw = raw;\n\n   this.remote = null;\n   this.branches = [];\n   this.tags = [];\n}\n\nFetchSummary.parsers = [\n   [\n      /From (.+)$/, function (fetchSummary, matches) {\n         fetchSummary.remote = matches[0];\n      }\n   ],\n   [\n      /\\* \\[new branch\\]\\s+(\\S+)\\s*\\-> (.+)$/, function (fetchSummary, matches) {\n         fetchSummary.branches.push({\n            name: matches[0],\n            tracking: matches[1]\n         });\n      }\n   ],\n   [\n      /\\* \\[new tag\\]\\s+(\\S+)\\s*\\-> (.+)$/, function (fetchSummary, matches) {\n         fetchSummary.tags.push({\n            name: matches[0],\n            tracking: matches[1]\n         });\n      }\n   ]\n];\n\nFetchSummary.parse = function (data) {\n   var fetchSummary = new FetchSummary(data);\n\n   String(data)\n      .trim()\n      .split('\\n')\n      .forEach(function (line) {\n         var original = line.trim();\n         FetchSummary.parsers.some(function (parser) {\n            var parsed = parser[0].exec(original);\n            if (parsed) {\n               parser[1](fetchSummary, parsed.slice(1));\n               return true;\n            }\n         });\n      });\n\n   return fetchSummary;\n};\n\nmodule.exports = FetchSummary;\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/responses/FileStatusSummary.js":"'use strict';\n\nfunction FileStatusSummary (path, index, working_dir) {\n   this.path = path;\n   this.index = index;\n   this.working_dir = working_dir;\n\n   if ('R' === index + working_dir) {\n      var detail = FileStatusSummary.fromPathRegex.exec(path) || [null, path, path];\n      this.from = detail[1];\n      this.path = detail[2];\n   }\n}\n\nFileStatusSummary.fromPathRegex = /^(.+) \\-> (.+)$/;\n\nFileStatusSummary.prototype = {\n   path: '',\n   from: ''\n};\n\nmodule.exports = FileStatusSummary;\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/responses/ListLogSummary.js":"\nmodule.exports = ListLogSummary;\n\n/**\n * The ListLogSummary is returned as a response to getting `git().log()` or `git().stashList()`\n *\n * @constructor\n */\nfunction ListLogSummary (all) {\n   this.all = all;\n   this.latest = all.length && all[0] || null;\n   this.total = all.length;\n}\n\n/**\n * Detail for each of the log lines\n * @type {ListLogLine[]}\n */\nListLogSummary.prototype.all = null;\n\n/**\n * Most recent entry in the log\n * @type {ListLogLine}\n */\nListLogSummary.prototype.latest = null;\n\n/**\n * Number of items in the log\n * @type {number}\n */\nListLogSummary.prototype.total = 0;\n\nfunction ListLogLine (line, fields) {\n   for (var k = 0; k < fields.length; k++) {\n      this[fields[k]] = line[k];\n   }\n}\n\nListLogSummary.COMMIT_BOUNDARY = '------------------------ >8 ------------------------';\n\nListLogSummary.parse = function (text, splitter, fields) {\n   fields = fields || ['hash', 'date', 'message', 'author_name', 'author_email'];\n   return new ListLogSummary(\n      text\n         .split(ListLogSummary.COMMIT_BOUNDARY + '\\n')\n         .map(function (item) {\n            return item.replace(ListLogSummary.COMMIT_BOUNDARY, '')\n         })\n         .filter(Boolean)\n         .map(function (item) {\n            return new ListLogLine(item.trim().split(splitter), fields);\n         })\n   );\n};\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/responses/PullSummary.js":"\nmodule.exports = PullSummary;\n\n/**\n * The PullSummary is returned as a response to getting `git().pull()`\n *\n * @constructor\n */\nfunction PullSummary () {\n   this.files = [];\n   this.insertions = {};\n   this.deletions = {};\n\n   this.summary = {\n      changes: 0,\n      insertions: 0,\n      deletions: 0\n   }\n}\n\n/**\n * The array of file paths/names that have been modified in any part of the pulled content\n * @type {string[]}\n */\nPullSummary.prototype.files = null;\n\n/**\n * A map of file path to number to show the number of insertions per file.\n * @type {Object}\n */\nPullSummary.prototype.insertions = null;\n\n/**\n * A map of file path to number to show the number of deletions per file.\n * @type {Object}\n */\nPullSummary.prototype.deletions = null;\n\n/**\n * Overall summary of changes/insertions/deletions and the number associated with each\n * across all content that was pulled.\n * @type {Object}\n */\nPullSummary.prototype.summary = null;\n\nPullSummary.FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s(\\+*)(\\-*)/;\nPullSummary.SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(\\-\\))?/;\n\nPullSummary.parse = function (text) {\n   var pullSummary = new PullSummary;\n\n   for (var lines = text.split('\\n'), i = 0, l = lines.length; i < l; i++) {\n      var update = PullSummary.FILE_UPDATE_REGEX.exec(lines[i]);\n\n      // search for update statement for each file\n      if (update) {\n         pullSummary.files.push(update[1]);\n\n         var insertions = update[2].length;\n         if (insertions) {\n            pullSummary.insertions[update[1]] = insertions;\n         }\n\n         var deletions = update[3].length;\n         if (deletions) {\n            pullSummary.deletions[update[1]] = deletions;\n         }\n      }\n\n      // summary appears after updates\n      else if (pullSummary.files.length &&\n               (update = PullSummary.SUMMARY_REGEX.exec(lines[i])) &&\n               !(typeof(update[3]) === 'undefined' && typeof(update[5]) === 'undefined'))\n      {\n         pullSummary.summary.changes = +update[1] || 0;\n         pullSummary.summary.insertions = +update[3] || 0;\n         pullSummary.summary.deletions = +update[5] || 0;\n      }\n   }\n\n   return pullSummary;\n};\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/responses/StatusSummary.js":"\nvar FileStatusSummary = require('./FileStatusSummary');\n\nmodule.exports = StatusSummary;\n\n/**\n * The StatusSummary is returned as a response to getting `git().status()`\n *\n * @constructor\n */\nfunction StatusSummary () {\n   this.not_added = [];\n   this.conflicted = [];\n   this.created = [];\n   this.deleted = [];\n   this.modified = [];\n   this.renamed = [];\n   this.files = [];\n}\n\n/**\n * Number of commits ahead of the tracked branch\n * @type {number}\n */\nStatusSummary.prototype.ahead = 0;\n\n/**\n * Number of commits behind the tracked branch\n * @type {number}\n */\nStatusSummary.prototype.behind = 0;\n\n/**\n * Name of the current branch\n * @type {null}\n */\nStatusSummary.prototype.current = null;\n\n/**\n * Name of the branch being tracked\n * @type {string}\n */\nStatusSummary.prototype.tracking = null;\n\n/**\n * All files represented as an array of objects containing the `path` and status in `index` and\n * in the `working_dir`.\n *\n * @type {Array}\n */\nStatusSummary.prototype.files = null;\n\n/**\n * Gets whether this StatusSummary represents a clean working branch.\n *\n * @return {boolean}\n */\nStatusSummary.prototype.isClean = function () {\n   return 0 === Object.keys(this).filter(function (name) {\n      return Array.isArray(this[name]) && this[name].length;\n   }, this).length;\n};\n\nStatusSummary.parsers = {\n   '##': function (line, status) {\n      var aheadReg = /ahead (\\d+)/;\n      var behindReg = /behind (\\d+)/;\n      var currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n      var trackingReg = /\\.{3}(\\S*)/;\n      var regexResult;\n\n      regexResult = aheadReg.exec(line);\n      status.ahead = regexResult && +regexResult[1] || 0;\n\n      regexResult = behindReg.exec(line);\n      status.behind = regexResult && +regexResult[1] || 0;\n\n      regexResult = currentReg.exec(line);\n      status.current = regexResult && regexResult[1];\n\n      regexResult = trackingReg.exec(line);\n      status.tracking = regexResult && regexResult[1];\n   },\n\n   '??': function (line, status) {\n      status.not_added.push(line);\n   },\n\n   A: function (line, status) {\n      status.created.push(line);\n   },\n\n   AM: function (line, status) {\n      status.created.push(line);\n   },\n\n   D: function (line, status) {\n      status.deleted.push(line);\n   },\n\n   M: function (line, status) {\n      status.modified.push(line);\n   },\n\n   R: function (line, status) {\n      var detail = /^(.+) \\-> (.+)$/.exec(line) || [null, line, line];\n\n      status.renamed.push({\n         from: detail[1],\n         to: detail[2]\n      });\n   },\n\n   UU: function (line, status) {\n      status.conflicted.push(line);\n   }\n};\n\nStatusSummary.parse = function (text) {\n   var line, linestr, handler;\n\n   var lines = text.split('\\n');\n   var status = new StatusSummary();\n\n   while (linestr = lines.shift()) {\n      line = linestr.match(/(..?)\\s+(.*)/);\n      if (!line || !line[1].trim()) {\n         line = linestr.trim().match(/(..?)\\s+(.*)/);\n      }\n\n      if (line) {\n         if ((handler = StatusSummary.parsers[line[1].trim()])) {\n            handler(line[2], status);\n         }\n\n         if (line[1] != '##') {\n            status.files.push(new FileStatusSummary(line[2], line[1][0], line[1][1]));\n         }\n      }\n   }\n\n   return status;\n};\n","/home/travis/build/npmtest/node-npmtest-simple-git/node_modules/simple-git/src/responses/TagList.js":"\nmodule.exports = TagList;\n\nfunction TagList (tagList, latest) {\n   this.latest = latest;\n   this.all = tagList\n}\n\nTagList.parse = function (data, customSort) {\n   var number = function (input) {\n      if (typeof input === 'string') {\n         return parseInt(input.replace(/^\\D+/g, ''), 10) || 0;\n      }\n\n      return 0;\n   };\n\n   var tags = data\n      .trim()\n      .split('\\n')\n      .map(function (item) { return item.trim(); })\n      .filter(Boolean);\n\n   if (!customSort) {\n      tags.sort(function (tagA, tagB) {\n         var partsA = tagA.split('.');\n         var partsB = tagB.split('.');\n\n         if (partsA.length === 1 || partsB.length === 1) {\n            return tagA - tagB > 0 ? 1 : -1;\n         }\n\n         for (var i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            var a = number(partsA[i]);\n            var b = number(partsB[i]);\n\n            var diff = a - b;\n            if (diff) {\n               return diff > 0 ? 1 : -1;\n            }\n         }\n\n         return 0;\n      });\n   }\n\n   var latest = customSort ? tags[0] : tags.filter(function (tag) { return tag.indexOf('.') >= 0; }).pop();\n\n   return new TagList(tags, latest);\n};\n"}