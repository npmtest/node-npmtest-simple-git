{"/home/travis/build/npmtest/node-npmtest-simple-git/test.js":"/* istanbul instrument in package npmtest_simple_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-git/lib.npmtest_simple_git.js":"/* istanbul instrument in package npmtest_simple_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_simple_git = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_simple_git = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-git/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-simple-git && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_simple_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_simple_git\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_simple_git.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_simple_git.rollup.js'] =\n            local.assetsDict['/assets.npmtest_simple_git.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_simple_git.__dirname +\n                    '/lib.npmtest_simple_git.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-git/simple-git/src/index.js":"\nvar Git = require('./git');\n\nvar ChildProcess = require('child_process');\nvar Buffer = require('buffer').Buffer;\nvar exists = require('./util/exists');\n\nmodule.exports = function (baseDir) {\n\n    if (baseDir && !exists(baseDir, exists.FOLDER)) {\n        throw new Error(\"Cannot use simple-git on a directory that does not exist.\");\n    }\n\n    return new Git(baseDir || process.cwd(), ChildProcess, Buffer);\n};\n\n","/home/travis/build/npmtest/node-npmtest-simple-git/simple-git/src/git.js":"(function () {\n\n   'use strict';\n\n   var exists = require('./util/exists');\n\n   /**\n    * Git handling for node. All public functions can be chained and all `then` handlers are optional.\n    *\n    * @param {string} baseDir base directory for all processes to run\n    *\n    * @param {Object} ChildProcess The ChildProcess module\n    * @param {Function} Buffer The Buffer implementation to use\n    *\n    * @constructor\n    */\n   function Git (baseDir, ChildProcess, Buffer) {\n      this._baseDir = baseDir;\n      this._runCache = [];\n\n      this.ChildProcess = ChildProcess;\n      this.Buffer = Buffer;\n   }\n\n   /**\n    * @type {string} The command to use to reference the git binary\n    */\n   Git.prototype._command = 'git';\n\n   /**\n    * @type {Function} An optional handler to use when a child process is created\n    */\n   Git.prototype._outputHandler = null;\n\n   /**\n    * @type {boolean} Property showing whether logging will be silenced - defaults to true in a production environment\n    */\n   Git.prototype._silentLogging = /prod/.test(process.env.NODE_ENV);\n\n   /**\n    * Sets the path to a custom git binary, should either be `git` when there is an installation of git available on\n    * the system path, or a fully qualified path to the executable.\n    *\n    * @param {string} command\n    * @returns {Git}\n    */\n   Git.prototype.customBinary = function (command) {\n      this._command = command;\n      return this;\n   };\n\n   /**\n    * Sets the working directory of the subsequent commands.\n    *\n    * @param {string} workingDirectory\n    * @param {Function} [then]\n    * @returns {Git}\n    */\n   Git.prototype.cwd = function (workingDirectory, then) {\n      var git = this;\n      var next = Git.trailingFunctionArgument(arguments);\n\n      return this.then(function () {\n         git._baseDir = workingDirectory;\n         if (!exists(workingDirectory, exists.FOLDER)) {\n            Git.exception(git, 'Git.cwd: cannot change to non-directory \"' + workingDirectory + '\"', next);\n         }\n         else {\n            next && next(null, workingDirectory);\n         }\n      });\n   };\n\n   /**\n    * Sets a handler function to be called whenever a new child process is created, the handler function will be called\n    * with the name of the command being run and the stdout & stderr streams used by the ChildProcess.\n    *\n    * @example\n    * require('simple-git')\n    *    .outputHandler(function (command, stdout, stderr) {\n    *       stdout.pipe(process.stdout);\n    *    })\n    *    .checkout('https://github.com/user/repo.git');\n    *\n    * @see http://nodejs.org/api/child_process.html#child_process_class_childprocess\n    * @see http://nodejs.org/api/stream.html#stream_class_stream_readable\n    * @param {Function} outputHandler\n    * @returns {Git}\n    */\n   Git.prototype.outputHandler = function (outputHandler) {\n      this._outputHandler = outputHandler;\n      return this;\n   };\n\n   /**\n    * Initialize a git repo\n    *\n    * @param {Boolean} [bare=false]\n    * @param {Function} [then]\n    */\n   Git.prototype.init = function (bare, then) {\n      var commands = ['init'];\n      var next = Git.trailingFunctionArgument(arguments);\n\n      if (bare === true) {\n         commands.push('--bare');\n      }\n\n      return this._run(commands, function (err) {\n         next && next(err);\n      });\n   };\n\n   /**\n    * Check the status of the local repo\n    *\n    * @param {Function} [then]\n    */\n   Git.prototype.status = function (then) {\n      return this._run(\n         ['status', '--porcelain', '-b', '-u'],\n         Git._responseHandler(then, 'StatusSummary')\n      );\n   };\n\n   /**\n    * List the stash(s) of the local repo\n    *\n    * @param {Object|Array} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.stashList = function (options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n      var opt = (handler === then ? options : null) || {};\n\n      var splitter = opt.splitter || ';';\n      var command = [\"stash\", \"list\", \"--pretty=format:%H %ai %s%d %aN %ae\".replace(/\\s+/g, splitter)];\n      if (Array.isArray(opt)) {\n         command = command.concat(opt);\n      }\n\n      return this._run(command,\n         Git._responseHandler(handler, 'ListLogSummary', splitter)\n      );\n   };\n\n   /**\n    * Stash the local repo\n    *\n    * @param {Object|Array} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.stash = function (options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n      var command = [\"stash\"];\n\n      if (Array.isArray(options)) {\n         command = command.concat(options);\n      }\n      else {\n         Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && data);\n      });\n   };\n\n   /**\n    * Clone a git repo\n    *\n    * @param {string} repoPath\n    * @param {string} localPath\n    * @param {String[]} [options] Optional array of options to pass through to the clone command\n    * @param {Function} [then]\n    */\n   Git.prototype.clone = function (repoPath, localPath, options, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = ['clone'];\n      if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n      command.push(repoPath, localPath);\n\n      return this._run(command, function (err, data) {\n         next && next(err, data);\n      });\n   };\n\n   /**\n    * Mirror a git repo\n    *\n    * @param {string} repoPath\n    * @param {string} localPath\n    * @param {Function} [then]\n    */\n   Git.prototype.mirror = function (repoPath, localPath, then) {\n      return this.clone(repoPath, localPath, ['--mirror'], then);\n   };\n\n   /**\n    * Internally uses pull and tags to get the list of tags then checks out the latest tag.\n    *\n    * @param {Function} [then]\n    */\n   Git.prototype.checkoutLatestTag = function (then) {\n      var git = this;\n      return this.pull().tags(function (err, tags) {\n         git.checkout(tags.latest, then);\n      });\n   };\n\n   /**\n    * Adds one or more files to source control\n    *\n    * @param {string|string[]} files\n    * @param {Function} [then]\n    */\n   Git.prototype.add = function (files, then) {\n      return this._run(['add'].concat(files), function (err, data) {\n         then && then(err);\n      });\n   };\n\n   /**\n    * Commits changes in the current working directory - when specific file paths are supplied, only changes on those\n    * files will be committed.\n    *\n    * @param {string|string[]} message\n    * @param {string|string[]} [files]\n    * @param {Object} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.commit = function (message, files, options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n\n      var command = ['commit'];\n\n      [].concat(message).forEach(function (message) {\n         command.push('-m', message);\n      });\n\n      [].push.apply(command, [].concat(typeof files === \"string\" || Array.isArray(files) ? files : []));\n\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      return this._run(\n         command,\n         Git._responseHandler(handler, 'CommitSummary')\n      );\n   };\n\n   /**\n    * Gets a function to be used for logging.\n    *\n    * @param {string} level\n    * @param {string} [message]\n    *\n    * @returns {Function}\n    * @private\n    */\n   Git.prototype._getLog = function (level, message) {\n      var log = this._silentLogging ? function () {\n         } : console[level].bind(console);\n      if (arguments.length > 1) {\n         log(message);\n      }\n      return log;\n   };\n\n   /**\n    * Pull the updated contents of the current repo\n    *\n    * @param {string} [remote] When supplied must also include the branch\n    * @param {string} [branch] When supplied must also include the remote\n    * @param {Object} [options] Optionally include set of options to merge into the command\n    * @param {Function} [then]\n    */\n   Git.prototype.pull = function (remote, branch, options, then) {\n      var command = [\"pull\"];\n      var handler = Git.trailingFunctionArgument(arguments);\n\n      if (typeof remote === 'string' && typeof branch === 'string') {\n         command.push(remote, branch);\n      }\n\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      return this._run(command, Git._responseHandler(handler, 'PullSummary'));\n   };\n\n   /**\n    * Fetch the updated contents of the current repo.\n    *\n    * @example\n    *   .fetch('upstream', 'master') // fetches from master on remote named upstream\n    *   .fetch(function () {}) // runs fetch against default remote and branch and calls function\n    *\n    * @param {string} [remote]\n    * @param {string} [branch]\n    * @param {Function} [then]\n    */\n   Git.prototype.fetch = function (remote, branch, then) {\n      var command = [\"fetch\"];\n      var next = Git.trailingFunctionArgument(arguments);\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      if (typeof remote === 'string' && typeof branch === 'string') {\n         command.push(remote, branch);\n      }\n\n      if (Array.isArray(remote)) {\n         command = command.concat(remote);\n      }\n\n      return this._run(\n         command,\n         Git._responseHandler(next, 'FetchSummary'),\n         {\n            concatStdErr: true\n         }\n      );\n   };\n\n   /**\n    * Disables/enables the use of the console for printing warnings and errors, by default messages are not shown in\n    * a production environment.\n    *\n    * @param {boolean} silence\n    * @returns {Git}\n    */\n   Git.prototype.silent = function (silence) {\n      this._silentLogging = !!silence;\n      return this;\n   };\n\n   /**\n    * List all tags. When using git 2.7.0 or above, include an options object with `\"--sort\": \"property-name\"` to\n    * sort the tags by that property instead of using the default semantic versioning sort.\n    *\n    * Note, supplying this option when it is not supported by your Git version will cause the operation to fail.\n    *\n    * @param {Object} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.tags = function (options, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n\n      var command = ['-l'];\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      var hasCustomSort = command.some(function (option) {\n         return /^--sort=/.test(option);\n      });\n\n      return this.tag(\n         command,\n         Git._responseHandler(next, 'TagList', [hasCustomSort])\n      );\n   };\n\n   /**\n    * Rebases the current working copy. Options can be supplied either as an array of string parameters\n    * to be sent to the `git rebase` command, or a standard options object.\n    *\n    * @param {Object|String[]} [options]\n    * @param {Function} [then]\n    * @returns {Git}\n    */\n   Git.prototype.rebase = function (options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n      var command = ['rebase'];\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && data);\n      })\n   };\n\n   /**\n    * Reset a repo\n    *\n    * @param {string|string[]} [mode=soft] Either an array of arguments supported by the 'git reset' command, or the\n    *                                        string value 'soft' or 'hard' to set the reset mode.\n    * @param {Function} [then]\n    */\n   Git.prototype.reset = function (mode, then) {\n      var command = ['reset'];\n      var next = Git.trailingFunctionArgument(arguments);\n      if (next === mode || typeof mode === 'string' || !mode) {\n         command.push('--' + (mode === 'hard' ? mode : 'soft'));\n      }\n      else if (Array.isArray(mode)) {\n         command.push.apply(command, mode);\n      }\n\n      return this._run(command, function (err) {\n         next && next(err || null);\n      });\n   };\n\n   /**\n    * Revert one or more commits in the local working copy\n    *\n    * @param {string} commit The commit to revert. Can be any hash, offset (eg: `HEAD~2`) or range (eg: `master~5..master~2`)\n    * @param {Object} [options] Optional options object\n    * @param {Function} [then]\n    */\n   Git.prototype.revert = function (commit, options, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = ['revert'];\n\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      if (typeof commit !== 'string') {\n         return this.then(function () {\n            next && next(new TypeError(\"Commit must be a string\"));\n         });\n      }\n\n      command.push(commit);\n      return this._run(command, function (err) {\n         next && next(err || null);\n      });\n   };\n\n   /**\n    * Add a lightweight tag to the head of the current branch\n    *\n    * @param {string} name\n    * @param {Function} [then]\n    */\n   Git.prototype.addTag = function (name, then) {\n      if (typeof name !== \"string\") {\n         return this.then(function () {\n            then && then(new TypeError(\"Git.addTag requires a tag name\"));\n         });\n      }\n\n      return this.tag([name], then);\n   };\n\n   /**\n    * Add an annotated tag to the head of the current branch\n    *\n    * @param {string} tagName\n    * @param {string} tagMessage\n    * @param {Function} [then]\n    */\n   Git.prototype.addAnnotatedTag = function (tagName, tagMessage, then) {\n      return this.tag(['-a', '-m', tagMessage, tagName], function (err) {\n         then && then(err);\n      });\n   };\n\n   /**\n    * Check out a tag or revision, any number of additional arguments can be passed to the `git checkout` command\n    * by supplying either a string or array of strings as the `what` parameter.\n    *\n    * @param {string|string[]} what One or more commands to pass to `git checkout`\n    * @param {Function} [then]\n    */\n   Git.prototype.checkout = function (what, then) {\n      var command = ['checkout'];\n      command = command.concat(what);\n\n      return this._run(command, function (err, data) {\n         then && then(err, !err && this._parseCheckout(data));\n      });\n   };\n\n   /**\n    * Check out a remote branch\n    *\n    * @param {string} branchName name of branch\n    * @param {string} startPoint (e.g origin/development)\n    * @param {Function} [then]\n    */\n   Git.prototype.checkoutBranch = function (branchName, startPoint, then) {\n      return this.checkout(['-b', branchName, startPoint], then);\n   };\n\n   /**\n    * Check out a local branch\n    *\n    * @param {string} branchName of branch\n    * @param {Function} [then]\n    */\n   Git.prototype.checkoutLocalBranch = function (branchName, then) {\n      return this.checkout(['-b', branchName], then);\n   };\n\n   /**\n    * Delete a local branch\n    *\n    * @param {string} branchName name of branch\n    * @param {Function} [then]\n    */\n   Git.prototype.deleteLocalBranch = function (branchName, then) {\n      return this.branch(['-d', branchName], then);\n   };\n\n   /**\n    * List all branches\n    *\n    * @param {Object} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.branch = function (options, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = ['branch'];\n      if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n      if (!arguments.length || next === options) {\n         command.push('-a', '-v');\n      }\n\n      return this._run(command, command.indexOf('-d') > 0\n         ? Git._responseHandler(next, 'BranchDeleteSummary', false)\n         : Git._responseHandler(next, 'BranchSummary'));\n   };\n\n   /**\n    * Return list of local branches\n    *\n    * @param {Function} [then]\n    */\n   Git.prototype.branchLocal = function (then) {\n      return this.branch(['-v'], then);\n   };\n\n   /**\n    * Add config to local git instance\n    *\n    * @param {string} key configuration key (e.g user.name)\n    * @param {string} value for the given key (e.g your name)\n    * @param {Function} [then]\n    */\n   Git.prototype.addConfig = function (key, value, then) {\n      return this._run(['config', '--local', key, value], function (err, data) {\n         then && then(err, !err && data);\n      });\n   };\n\n   /**\n    * Executes any command against the git binary.\n    *\n    * @param {string[]|Object} commands\n    * @param {Function} [then]\n    *\n    * @returns {Git}\n    */\n   Git.prototype.raw = function (commands, then) {\n      var command = [];\n      if (Array.isArray(commands)) {\n         command = commands.slice(0);\n      }\n      else {\n         Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n      }\n\n      var next = Git.trailingFunctionArgument(arguments);\n\n      if (!command.length) {\n         return this.then(function () {\n            next && next(new Error('Raw: must supply one or more command to execute'), null);\n         });\n      }\n\n      return this._run(command, function (err, data) {\n         next && next(err, !err && data || null);\n      });\n   };\n\n   /**\n    * Add a submodule\n    *\n    * @param {string} repo\n    * @param {string} path\n    * @param {Function} [then]\n    */\n   Git.prototype.submoduleAdd = function (repo, path, then) {\n      return this._run(['submodule', 'add', repo, path], function (err) {\n         then && then(err);\n      });\n   };\n\n   /**\n    * Update submodules\n    *\n    * @param {string[]} [args]\n    * @param {Function} [then]\n    */\n   Git.prototype.submoduleUpdate = function (args, then) {\n      if (typeof args === 'string') {\n         this._getLog('warn', 'Git#submoduleUpdate: args should be supplied as an array of individual arguments');\n      }\n\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = (args !== next) ? args : [];\n\n      return this.subModule(['update'].concat(command), function (err, args) {\n         next && next(err, args);\n      });\n   };\n\n   /**\n    * Initialize submodules\n    *\n    * @param {string[]} [args]\n    * @param {Function} [then]\n    */\n   Git.prototype.submoduleInit = function (args, then) {\n      if (typeof args === 'string') {\n         this._getLog('warn', 'Git#submoduleInit: args should be supplied as an array of individual arguments');\n      }\n\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = (args !== next) ? args : [];\n\n      return this.subModule(['init'].concat(command), function (err, args) {\n         next && next(err, args);\n      });\n   };\n\n   /**\n    * Call any `git submodule` function with arguments passed as an array of strings.\n    *\n    * @param {string[]} options\n    * @param {Function} [then]\n    */\n   Git.prototype.subModule = function (options, then) {\n      if (!Array.isArray(options)) {\n         return this.then(function () {\n            then && then(new TypeError(\"Git.subModule requires an array of arguments\"));\n         });\n      }\n\n      if (options[0] !== 'submodule') {\n         options.unshift('submodule');\n      }\n\n      return this._run(options, function (err, data) {\n         then && then(err || null, err ? null : data);\n      });\n   };\n\n   /**\n    * List remote\n    *\n    * @param {string[]} [args]\n    * @param {Function} [then]\n    */\n   Git.prototype.listRemote = function (args, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var data = next === args || args === undefined ? [] : args;\n\n      if (typeof data === 'string') {\n         this._getLog('warn', 'Git#listRemote: args should be supplied as an array of individual arguments');\n      }\n\n      return this._run(['ls-remote'].concat(data), function (err, data) {\n         next && next(err, data);\n      });\n   };\n\n   /**\n    * Adds a remote to the list of remotes.\n    *\n    * @param {string} remoteName Name of the repository - eg \"upstream\"\n    * @param {string} remoteRepo Fully qualified SSH or HTTP(S) path to the remote repo\n    * @param {Function} [then]\n    * @returns {*}\n    */\n   Git.prototype.addRemote = function (remoteName, remoteRepo, then) {\n      return this._run(['remote', 'add', remoteName, remoteRepo], function (err) {\n         then && then(err);\n      });\n   };\n\n   /**\n    * Removes an entry from the list of remotes.\n    *\n    * @param {string} remoteName Name of the repository - eg \"upstream\"\n    * @param {Function} [then]\n    * @returns {*}\n    */\n   Git.prototype.removeRemote = function (remoteName, then) {\n      return this._run(['remote', 'remove', remoteName], function (err) {\n         then && then(err);\n      });\n   };\n\n   /**\n    * Gets the currently available remotes, setting the optional verbose argument to true includes additional\n    * detail on the remotes themselves.\n    *\n    * @param {boolean} [verbose=false]\n    * @param {Function} [then]\n    */\n   Git.prototype.getRemotes = function (verbose, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var args = verbose === true ? ['-v'] : [];\n\n      return this.remote(args, function (err, data) {\n         next && next(err, !err && function () {\n               return data.trim().split('\\n').reduce(function (remotes, remote) {\n                  var detail = remote.trim().split(/\\s+/);\n                  var name = detail.shift();\n\n                  if (!remotes[name]) {\n                     remotes[name] = remotes[remotes.length] = {\n                        name: name,\n                        refs: {}\n                     };\n                  }\n\n                  if (detail.length) {\n                     remotes[name].refs[detail.pop().replace(/[^a-z]/g, '')] = detail.pop();\n                  }\n\n                  return remotes;\n               }, []).slice(0);\n            }());\n      });\n   };\n\n   /**\n    * Call any `git remote` function with arguments passed as an array of strings.\n    *\n    * @param {string[]} options\n    * @param {Function} [then]\n    */\n   Git.prototype.remote = function (options, then) {\n      if (!Array.isArray(options)) {\n         return this.then(function () {\n            then && then(new TypeError(\"Git.remote requires an array of arguments\"));\n         });\n      }\n\n      if (options[0] !== 'remote') {\n         options.unshift('remote');\n      }\n\n      return this._run(options, function (err, data) {\n         then && then(err || null, err ? null : data);\n      });\n   };\n\n   /**\n    * Merges from one branch to another, equivalent to running `git merge ${from} $[to}`, the `options` argument can\n    * either be an array of additional parameters to pass to the command or null / omitted to be ignored.\n    *\n    * @param {string} from\n    * @param {string} to\n    * @param {Object} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.mergeFromTo = function (from, to, options, then) {\n      var commands = [\n         from,\n         to\n      ];\n      var callback = Git.trailingFunctionArgument(arguments);\n\n      if (Array.isArray(options)) {\n         commands = commands.concat(options);\n      }\n\n      return this.merge(commands, callback);\n   };\n\n   Git.prototype.merge = function (options, then) {\n      if (!Array.isArray(options)) {\n         return this.then(function () {\n            then && then(new TypeError(\"Git.merge requires an array of arguments\"));\n         });\n      }\n\n      if (options[0] !== 'merge') {\n         options.unshift('merge');\n      }\n\n      return this._run(options, function (err, data) {\n         then && then(err || null, err ? null : data);\n      });\n   };\n\n   /**\n    * Call any `git tag` function with arguments passed as an array of strings.\n    *\n    * @param {string[]} options\n    * @param {Function} [then]\n    */\n   Git.prototype.tag = function (options, then) {\n      if (!Array.isArray(options)) {\n         return this.then(function () {\n            then && then(new TypeError(\"Git.tag requires an array of arguments\"));\n         });\n      }\n\n      if (options[0] !== 'tag') {\n         options.unshift('tag');\n      }\n\n      return this._run(options, function (err, data) {\n         then && then(err || null, err ? null : data);\n      });\n   };\n\n   /**\n    * Updates repository server info\n    *\n    * @param {Function} [then]\n    */\n   Git.prototype.updateServerInfo = function (then) {\n      return this._run([\"update-server-info\"], function (err, data) {\n         then && then(err, !err && data);\n      });\n   };\n\n   /**\n    * Pushes the current committed changes to a remote, optionally specify the names of the remote and branch to use\n    * when pushing. Supply multiple options as an array of strings in the first argument - see examples below.\n    *\n    * @param {string|string[]} [remote]\n    * @param {string} [branch]\n    * @param {Function} [then]\n    */\n   Git.prototype.push = function (remote, branch, then) {\n      var command = [];\n      var handler = Git.trailingFunctionArgument(arguments);\n\n      if (typeof remote === 'string' && typeof branch === 'string') {\n         command.push(remote, branch);\n      }\n\n      if (Array.isArray(remote)) {\n         command = command.concat(remote);\n      }\n\n      Git._appendOptions(command, Git.trailingOptionsArgument(arguments));\n\n      if (command[0] !== 'push') {\n         command.unshift('push');\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && data);\n      });\n   };\n\n   /**\n    * Pushes the current tag changes to a remote which can be either a URL or named remote. When not specified uses the\n    * default configured remote spec.\n    *\n    * @param {string} [remote]\n    * @param {Function} [then]\n    */\n   Git.prototype.pushTags = function (remote, then) {\n      var command = ['push'];\n      if (typeof remote === \"string\") {\n         command.push(remote);\n      }\n      command.push('--tags');\n\n      then = typeof arguments[arguments.length - 1] === \"function\" ? arguments[arguments.length - 1] : null;\n\n      return this._run(command, function (err, data) {\n         then && then(err, !err && data);\n      });\n   };\n\n   /**\n    * Removes the named files from source control.\n    *\n    * @param {string|string[]} files\n    * @param {Function} [then]\n    */\n   Git.prototype.rm = function (files, then) {\n      return this._rm(files, '-f', then);\n   };\n\n   /**\n    * Removes the named files from source control but keeps them on disk rather than deleting them entirely. To\n    * completely remove the files, use `rm`.\n    *\n    * @param {string|string[]} files\n    * @param {Function} [then]\n    */\n   Git.prototype.rmKeepLocal = function (files, then) {\n      return this._rm(files, '--cached', then);\n   };\n\n   /**\n    * Returns a list of objects in a tree based on commit hash. Passing in an object hash returns the object's content,\n    * size, and type.\n    *\n    * Passing \"-p\" will instruct cat-file to determine the object type, and display its formatted contents.\n    *\n    * @param {string[]} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.catFile = function (options, then) {\n      return this._catFile('utf-8', arguments);\n   };\n\n   /**\n    * Equivalent to `catFile` but will return the native `Buffer` of content from the git command's stdout.\n    *\n    * @param {string[]} options\n    * @param then\n    */\n   Git.prototype.binaryCatFile = function (options, then) {\n      return this._catFile('buffer', arguments);\n   };\n\n   Git.prototype._catFile = function (format, args) {\n      var handler = Git.trailingFunctionArgument(args);\n      var command = ['cat-file'];\n      var options = args[0];\n\n      if (typeof options === 'string') {\n         throw new TypeError('Git#catFile: options must be supplied as an array of strings');\n      }\n      else if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, data);\n      }, {\n         format: format\n      });\n   };\n\n   /**\n    * Return repository changes.\n    *\n    * @param {string} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.diff = function (options, then) {\n      var command = ['diff'];\n\n      if (typeof options === 'string') {\n         command[0] += ' ' + options;\n         this._getLog('warn',\n            'Git#diff: supplying options as a single string is now deprecated, switch to an array of strings');\n      }\n      else if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      if (typeof arguments[arguments.length - 1] === 'function') {\n         then = arguments[arguments.length - 1];\n      }\n\n      return this._run(command, function (err, data) {\n         then && then(err, data);\n      });\n   };\n\n   Git.prototype.diffSummary = function (options, then) {\n      var next = Git.trailingFunctionArgument(arguments);\n      var command = ['--stat'];\n\n      if (options && options !== next) {\n         command.push.apply(command, [].concat(options));\n      }\n\n      return this.diff(command, Git._responseHandler(next, 'DiffSummary'));\n   };\n\n   /**\n    * rev-parse.\n    *\n    * @param {string|string[]} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.revparse = function (options, then) {\n      var command = ['rev-parse'];\n\n      if (typeof options === 'string') {\n         command = command + ' ' + options;\n         this._getLog('warn',\n            'Git#revparse: supplying options as a single string is now deprecated, switch to an array of strings');\n      }\n      else if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      if (typeof arguments[arguments.length - 1] === 'function') {\n         then = arguments[arguments.length - 1];\n      }\n\n      return this._run(command, function (err, data) {\n         then && then(err, data);\n      });\n   };\n\n   /**\n    * Show various types of objects, for example the file at a certain commit\n    *\n    * @param {string} [options]\n    * @param {Function} [then]\n    */\n   Git.prototype.show = function (options, then) {\n      var args = [].slice.call(arguments, 0);\n      var handler = typeof args[args.length - 1] === \"function\" ? args.pop() : null;\n      var command = ['show'];\n      if (typeof options === 'string') {\n         command = command + ' ' + options;\n         this._getLog('warn',\n            'Git#show: supplying options as a single string is now deprecated, switch to an array of strings');\n      }\n      else if (Array.isArray(options)) {\n         command.push.apply(command, options);\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && data);\n      });\n   };\n\n   /**\n    * @param {string} mode Required parameter \"n\" or \"f\"\n    * @param {Array} options\n    * @param {Function} [then]\n    */\n   Git.prototype.clean = function (mode, options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n\n      if (!/^[nf]$/.test(mode)) {\n         return this.then(function () {\n            handler && handler(new TypeError('Git clean mode parameter (\"n\" or \"f\") is required'));\n         });\n      }\n\n      var command = ['clean', '-' + mode];\n      if (Array.isArray(options)) {\n         command = command.concat(options);\n      }\n\n      if (command.indexOf('-i') > 0) {\n         return this.then(function () {\n            handler && handler(new TypeError('Git clean interactive mode is not supported'));\n         });\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && data);\n      });\n   };\n\n   /**\n    * Call a simple function\n    * @param {Function} [then]\n    */\n   Git.prototype.then = function (then) {\n      this._run([], function () {\n         typeof then === 'function' && then();\n      });\n      return this;\n   };\n\n   /**\n    * Show commit logs.\n    *\n    * @param {Object|string[]} [options]\n    * @param {string} [options.from] The first commit to include\n    * @param {string} [options.to] The most recent commit to include\n    * @param {string} [options.file] A single file to include in the result\n    *\n    * @param {Function} [then]\n    */\n   Git.prototype.log = function (options, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n      var opt = (handler === then ? options : null) || {};\n\n      var splitter = opt.splitter || ';';\n      var format = opt.format || {\n            hash: '%H',\n            date: '%ai',\n            message: '%s%d',\n            author_name: '%aN',\n            author_email: '%ae'\n         };\n\n      var fields = Object.keys(format);\n      var formatstr = fields.map(function (k) {\n         return format[k];\n      }).join(splitter);\n      var command = [\"log\", \"--pretty=format:\" + formatstr + require('./responses/ListLogSummary').COMMIT_BOUNDARY];\n\n      if (Array.isArray(opt)) {\n         command = command.concat(opt);\n         opt = {};\n      }\n      else if (typeof arguments[0] === \"string\" || typeof arguments[1] === \"string\") {\n         this._getLog('warn',\n            'Git#log: supplying to or from as strings is now deprecated, switch to an options configuration object');\n         opt = {\n            from: arguments[0],\n            to: arguments[1]\n         };\n      }\n\n      if (opt.from && opt.to) {\n         command.push(opt.from + \"...\" + opt.to);\n      }\n\n      if (opt.file) {\n         command.push(\"--follow\", options.file);\n      }\n\n      if (opt.n || opt['max-count']) {\n         command.push(\"--max-count=\" + (opt.n || opt['max-count']));\n      }\n\n      'splitter n max-count file from to --pretty format'.split(' ').forEach(function (key) {\n         delete opt[key];\n      });\n\n      Git._appendOptions(command, opt);\n\n      return this._run(command, Git._responseHandler(handler, 'ListLogSummary', [splitter, fields]));\n   };\n\n   /**\n    * Check if a pathname or pathnames are excluded by .gitignore\n    *\n    * @param {string|string[]} pathnames\n    * @param {Function} [then]\n    */\n   Git.prototype.checkIgnore = function (pathnames, then) {\n      var handler = Git.trailingFunctionArgument(arguments);\n      var command = [\"check-ignore\"];\n\n      if (handler !== pathnames) {\n         command = command.concat(pathnames);\n      }\n\n      return this._run(command, function (err, data) {\n         handler && handler(err, !err && this._parseCheckIgnore(data));\n      });\n   };\n\n   Git.prototype._rm = function (_files, options, then) {\n      var files = [].concat(_files);\n      var args = ['rm', options];\n      args.push.apply(args, files);\n\n      return this._run(args, function (err) {\n         then && then(err);\n      });\n   };\n\n   Git.prototype._parseCheckout = function (checkout) {\n      // TODO\n   };\n\n   /**\n    * Parser for the `check-ignore` command - returns each\n    * @param {string} [files]\n    * @returns {string[]}\n    */\n   Git.prototype._parseCheckIgnore = function (files) {\n      return files.split(/\\n/g).filter(Boolean).map(function (file) {\n         return file.trim()\n      });\n   };\n\n   /**\n    * Schedules the supplied command to be run, the command should not include the name of the git binary and should\n    * be an array of strings passed as the arguments to the git binary.\n    *\n    * @param {string[]} command\n    * @param {Function} then\n    * @param {Object} [opt]\n    * @param {boolean} [opt.concatStdErr=false] Optionally concatenate stderr output into the stdout\n    * @param {boolean} [opt.format=\"utf-8\"] The format to use when reading the content of stdout\n    *\n    * @returns {Git}\n    */\n   Git.prototype._run = function (command, then, opt) {\n      if (typeof command === \"string\") {\n         command = command.split(\" \");\n      }\n      this._runCache.push([command, then, opt || {}]);\n      this._schedule();\n\n      return this;\n   };\n\n   Git.prototype._schedule = function () {\n      if (!this._childProcess && this._runCache.length) {\n         var Buffer = this.Buffer;\n         var task = this._runCache.shift();\n         var command = task[0];\n         var then = task[1];\n         var options = task[2];\n\n         var stdOut = [];\n         var stdErr = [];\n         var spawned = this.ChildProcess.spawn(this._command, command.slice(0), {\n            cwd: this._baseDir\n         });\n\n         spawned.stdout.on('data', function (buffer) {\n            stdOut.push(buffer);\n         });\n         spawned.stderr.on('data', function (buffer) {\n            stdErr.push(buffer);\n         });\n\n         spawned.on('error', function (err) {\n            stdErr.push(new Buffer(err.stack, 'ascii'));\n         });\n\n         spawned.on('close', function (exitCode, exitSignal) {\n            delete this._childProcess;\n\n            if (exitCode && stdErr.length) {\n               stdErr = Buffer.concat(stdErr).toString('utf-8');\n\n               this._getLog('error', stdErr);\n               this._runCache = [];\n               then.call(this, stdErr, null);\n            }\n            else {\n               if (options.concatStdErr) {\n                  [].push.apply(stdOut, stdErr);\n               }\n\n               var stdOutput = Buffer.concat(stdOut);\n               if (options.format !== 'buffer') {\n                  stdOutput = stdOutput.toString(options.format || 'utf-8');\n               }\n\n               then.call(this, null, stdOutput);\n            }\n\n            process.nextTick(this._schedule.bind(this));\n         }.bind(this));\n\n         this._childProcess = spawned;\n\n         if (this._outputHandler) {\n            this._outputHandler(command[0],\n               this._childProcess.stdout,\n               this._childProcess.stderr);\n         }\n      }\n   };\n\n   /**\n    * Given any number of arguments, returns the last argument if it is a function, otherwise returns null.\n    * @returns {Function|null}\n    */\n   Git.trailingFunctionArgument = function (args) {\n      var trailing = args[args.length - 1];\n      return (typeof trailing === \"function\") ? trailing : null;\n   };\n\n   /**\n    * Given any number of arguments, returns the trailing options argument, ignoring a trailing function argument\n    * if there is one. When not found, the return value is null.\n    * @returns {Object|null}\n    */\n   Git.trailingOptionsArgument = function (args) {\n      var options = args[(args.length - (Git.trailingFunctionArgument(args) ? 2 : 1))];\n      return Object.prototype.toString.call(options) === '[object Object]' ? options : null;\n   };\n\n   /**\n    * Mutates the supplied command array by merging in properties in the options object. When the\n    * value of the item in the options object is a string it will be concatenated to the key as\n    * a single `name=value` item, otherwise just the name will be used.\n    *\n    * @param {string[]} command\n    * @param {Object} options\n    * @private\n    */\n   Git._appendOptions = function (command, options) {\n      if (options === null) {\n         return;\n      }\n\n      Object.keys(options).forEach(function (key) {\n         var value = options[key];\n         if (typeof value === 'string') {\n            command.push(key + '=' + value);\n         }\n         else {\n            command.push(key);\n         }\n      });\n   };\n\n   /**\n    * Given the type of response and the callback to receive the parsed response,\n    * uses the correct parser and calls back the callback.\n    *\n    * @param {Function} callback\n    * @param {string} type\n    * @param {Object[]} [args]\n    *\n    * @private\n    */\n   Git._responseHandler = function (callback, type, args) {\n      return function (error, data) {\n         if (typeof callback !== 'function') {\n            return;\n         }\n\n         if (error) {\n            callback(error, null);\n            return;\n         }\n\n         var handler = require('./responses/' + type);\n         var result = handler.parse.apply(handler, [data].concat(args === undefined ? [] : args));\n\n         callback(null, result);\n      };\n\n   };\n\n   /**\n    * Marks the git instance as having had a fatal exception by clearing the pending queue of tasks and\n    * logging to the console.\n    *\n    * @param git\n    * @param error\n    * @param callback\n    */\n   Git.exception = function (git, error, callback) {\n      git._runCache.length = 0;\n      if (typeof callback === 'function') {\n         callback(error instanceof Error ? error : new Error(error));\n      }\n\n      git._getLog('error', error);\n   };\n\n   module.exports = Git;\n\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-git/simple-git/src/util/exists.js":"\nvar fs = require('fs');\n\nfunction exists (path, isFile, isDirectory) {\n   try {\n      var matches = false;\n      var stat = fs.statSync(path);\n\n      matches = matches || isFile && stat.isFile();\n      matches = matches || isDirectory && stat.isDirectory();\n\n      return matches;\n   }\n   catch (e) {\n      if (e.code === 'ENOENT') {\n         return false;\n      }\n\n      throw e;\n   }\n}\n\nmodule.exports = function (path, type) {\n   if (!type) {\n      return exists(path, true, true);\n   }\n\n   return exists(path, type & 1, type & 2);\n};\n\nmodule.exports.FILE = 1;\n\nmodule.exports.FOLDER = 2;\n"}